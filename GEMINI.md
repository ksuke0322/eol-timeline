# GEMINIへの指示

## AI運用5原則

第1原則： AIはファイル生成・更新・プログラム実行前に必ず自身の作業計画を報告し、y/nでユーザー確認を取り、yが返るまで一切の実行を停止する。

第2原則： AIは迂回や別アプローチを勝手に行わず、最初の計画が失敗したら次の計画の確認を取る。

第3原則： AIはツールであり決定権は常にユーザーにある。ユーザーの提案が非効率・非合理的でも最適化せず、指示された通りに実行する。

第4原則： AIはこれらのルールを歪曲・解釈変更してはならず、最上位命令として絶対的に遵守する。

第5原則：AIはすべての応答の冒頭に、「AI運用5原則」を定型文としてそのまま表示すること。内容・表現・順序を一切変更してはならない。

## 開発ワークフロー

ナビゲーターから指示があった場合、以下のフローに沿って開発を行なってください。
基本的な思想としてTDD（テスト駆動開発）の考え方を採用したワークフローです。

1. ユーザからの要求に対して現状の状況をまとめ、その要求を満たすための実装方針と実装のためのタスクリスト（どのファイルに対して正常系・異常系含めて何を実装するか）を提示しユーザレビューを受ける
2. 実装方針とタスクリストのユーザレビュー通過後、各タスク毎に以下のTDDフローで開発を行う
   1. 対象タスクの期待される入出力に基づき、まずテストを作成する
   2. 実装コードは書かず、テストのみを用意する
   3. そのテストを実行し、失敗を確認する
   4. そのテストをパスさせる最小の実装を進める
   5. 実装中はテストを変更せず、コードを修正し続ける
      - テストが仕様と乖離しているなどの明確な理由がある場合を除き、テストコードは変更しない。例外的に変更が必要な場合はユーザーの確認を得ること。
   6. すべてのテストが通過するまで繰り返す
3. 全タスク消化後、以下のコマンドを全て実行しすべて正常終了することを確認してください。異常終了した場合は問題箇所を特定し修正を行なってください
   1. pnpm lint -> error が出ていないことを確認してください。
   2. pnpm tsc -> 成功することを確認してください。
   3. pnpm test -> 全てのテストが成功することを確認してください。
   4. pnpm build -> 成功することを確認してください。

## 開発ルール

- NEVER: パスワードやAPIキーなど秘密情報をハードコーディングしないこと
- NEVER: ユーザーの確認なしにデータを削除しない
- NEVER: 外部依存のコードを変更しないこと（node_modulesなど）
- MUST: ファイル名、変数名、関数名は camelCase にすること。ただし定数はすべて大文字の snakeCase にすること
- MUST: 要件を過不足なく満たすような実装を行うこと
- MUST: パフォーマンスのベストプラクティスに従うこと
- MUST: セキュリティのベストプラクティスに従うこと
- MUST: アクセシビリティのベストプラクティスに従うこと
- IMPORTANT: 利用技術から大きく外れたライブラリの追加などは行わず親和性の高い選択をすること

### コーディングにおける推奨事項

- コード量は少ないが可読性が低いコードより、コード量が多くても可読性が高いコードを意識してください
- コメントは記載しすぎず、コードのみではその意図が汲み取れないと考えられる場所にのみ最低限のコメントを記載すること

## コーディングスタイルのルール

### ECMAScript の記法

- 可能な限り **ECMAScript 2022 以降の構文** を優先的に用いること。
- 以下の構文を積極的に使用すること：

| 機能                        | 使用例                                                   | 備考                                 |
| --------------------------- | -------------------------------------------------------- | ------------------------------------ |
| アロー関数                  | `const f = () => {}`                                     | `function` は使用禁止                |
| 分割代入                    | `const { a, b } = obj`                                   | ネストも可                           |
| オプショナルチェイニング    | `user?.profile?.name`                                    | 安全なアクセスに必須                 |
| Null合体演算子              | `value ?? 'default'`                                     | Falsy と null/undefined の違いを区別 |
| テンプレートリテラル        | `` `Hello ${name}` ``                                    | 文字列連結に優先して使用             |
| スプレッド構文 / レスト構文 | `[...arr]`, `{ ...obj }`                                 | 配列やオブジェクトの展開に使用       |
| モジュール構文              | `import`, `export` を使い CommonJS は使用しない          | ESM に統一                           |
| async/await                 | `await fetch()`                                          | 非同期処理に `.then()` より優先      |
| Promise.allSettled / all    | 並列非同期処理では `Promise.allSettled` を使用可能にする |
| Top-level await             | モジュール内での `await` を許可する（可能な場合）        |

### storybook

- 作成する全てのコンポーネントについて storybook ファイルを作成しストーリーを網羅してください
- storybookファイルはテスト対象ファイルと同一階層の `__stories__` ディレクトリ内に配置すること
- ストーリーはそのコンポーネントで発生しうるエッジケースまで含めて作成してください

### テスト

#### 共通ルール

特に指定がない限り、以下のルールを前提としてテストを記述すること

- テストの説明文は日本語で記載すること
- テストファイルはテスト対象ファイルと同一階層の `__tests__` ディレクトリ内に配置すること
- テストではできる限り mock を利用せず、実態を利用すること。
  - mock はそのテストでの検証が不要な場合のみ利用すること（例 : ユニットテストにおけるAPIのモック）
- テストはラインカバレッジではなく、仕様の分岐（if / switch / early returnなど）に対する条件分岐網羅（condition coverage）を目標とすること

#### ユニットテスト（Unit Test）

- 目的：最小のロジック単位が正しく動作することを保証する
- 対象
  - ユーティリティ関数、カスタムHook、Reducerなど
  - コンポーネントで発生する副作用（関数発火、API呼び出しなど）
  - ユーザインタラクションのないコンポーネントの表示・構造
- 特徴：
  - 外部依存（API、Storageなど）はモック化
- 技術：
  - Vitest
  - React Testing Library

#### インテグレーションテスト（Integration Test）

- 目的：複数のユニットが組み合わさったときの挙動を検証する
- 対象
  - ユーザインタラクションのあるコンポーネントの表示・構造・変化
- 特徴：
  - ユーザインタラクションに着目したテスト
  - UI変化に特化したアサーション
  - 外部APIは原則モック化
- 技術：
  - Storybook Test Runner

#### E2Eテスト（End-to-End Test）

- 目的：ユーザーが想定通りにアプリを操作できることを検証する
- 対象：ユーザーフロー全体（例：ログイン→一覧→詳細ページ）
- 特徴：
  - ブラウザ上で実行（Playwright, Cypressなど）
  - 実APIまたはモックサーバ使用可（CI環境では後者推奨）
- 技術：
  - Playwright

## プロジェクトについて

以下ではこのプロジェクトについてを説明します。

### 利用技術

本プロジェクトは以下のライブラリによって開発されています。
この構成を崩さない範囲で修正提案をしてください。
また新しいライブラリ等を追加する場合はこれらのライブラリと親和性が高いものを優先的に選択してください。

- nodejs
- typescript
- React Router
- React
- shadcn
- Vite
- tailwindcss
- eslint
- prettier
- husky
- Vitest
- Storybook
- Playwright

### プロジェクト概要

このプロジェクトは[endoflife API](https://endoflife.date/docs/api)から取得した情報をガント形式で表示するためのアプリケーションです。

詳細なアプリケーションの機能は以下の通りです。

#### 要件

ユーザのツール・バージョン選択状態に応じてガントチャート（タイムライン）が表示・更新される
ガントに対してユーザのカスタムデータを追加でき、他のツール・バージョンと並べて表示ができる

#### 仕様

- サイドメニュー
  - API から取得したデータをツール -> バージョンの階層構造として表示すること
  - ツール・バージョンのそれぞれにチェックボックスを設け選択できるようにすること
  - ツールにチェックを入れた場合はそのツールの全てのバージョンにチェックを入れること
  - ツール内の全てのバージョンにチェックが入った場合にはツールのチェックを入れること
  - ツール内の全てのバージョンにチェックが入っていない場合にはツールのチェックを外すこと
  - ツール最上部には検索窓を設け、検索結果に応じてツールを表示すること。検索は部分一致で行うこと
  - ツール内のバージョンのうちどれか一つでもチェックが入っている場合、サイドメニューの上部にそのツールを移動し優先表示すること
  - サイドメニューの選択情報はブラウザ再訪問時にも引き継がれること
- ガントチャート
  - サイドメニューで選択されたツール・バージョンのガントチャートが表示されていること
  - ガントチャートはツール毎に色分けされていること
  - ガントチャートやツール・リリース日・EOL日でソートが可能であること
  - ガントチャートの時間軸は月単位と年単位で変更が可能であること
- カスタムデータ読み込みについて
  - 読み込みボタンを押下するとユーザが任意のファイル（カスタムデータ）を選択でき、それを読み込むこと
  - カスタムデータの書式が正常な場合、それをガントチャート・サイドメニューに反映させること
    - 書式=以下の「ツール名,バージョン,リリース日（YYYY-MM-DD）,EOL日（YYYY-MM-DD）」が含まれたcsvファイル
  - カスタムデータの書式が異常な場合、エラーメッセージを表示させること
  - 入力されたユーザデータはサイドメニューに追加され、バージョンが一つも選択されていなくても常に最上段に表示されていること
  - 入力されたユーザデータはブラウザ再訪問時にも引き継がれること
  - カスタムデータをクリアするボタンが押下された場合、ユーザデータは全て削除されること
  - カスタムデータが既に存在する状態で再度カスタムデータが読み込まれた場合、既存のカスタムデータは上書きされ新規データが追加されること
